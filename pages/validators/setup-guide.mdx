import { Callout } from "nextra-theme-docs";

# Setting Up Your GenLayer Validator

Running a GenLayer Validator node ensures the security and reliability of the GenLayer network. Below are the requirements for running a GenLayer validator.

For a deeper understanding of how staking works in GenLayer, see the [Staking documentation](/understand-genlayer-protocol/core-concepts/optimistic-democracy/staking).

## Create the Validator Wallet

Before setting up your validator node, you need to create your validator wallet and stake GEN tokens.

### Understanding Validator Addresses

<Callout type="info">
GenLayer validators use three distinct addresses:

| Address | Description | Where Used |
|---------|-------------|------------|
| **Owner** | The only address that can withdraw staked funds. Keep this secure (cold wallet). | CLI wizard - signs staking transaction |
| **Operator** | Hot wallet on your server that signs blocks. Can be same as owner, but separate is recommended. | Node config: `operatorAddress` |
| **Validator Wallet** | Smart contract created when you join. This is your validator's on-chain identity. | Node config: `validatorWalletAddress` |

The wizard outputs all three addresses at the end. Save them - you'll need the Validator Wallet and Operator addresses for your node configuration.
</Callout>

### Prerequisites

- **Node.js** (v18 or higher)
- **GenLayer CLI** - Install the latest version:
  ```bash
  npm install -g genlayer
  ```
- **GEN tokens** - You need at least **42,000 GEN** for the minimum self-stake requirement

### Using the Validator Wizard

The easiest way to create your validator wallet is using the interactive wizard:

```bash
genlayer staking wizard
```

The wizard guides you through:

1. **Account setup** - Create or select your owner account
2. **Network selection** - Choose testnet-asimov
3. **Balance verification** - Confirms you have at least 42,000 GEN
4. **Operator setup** - Create and export an operator keystore for your validator server
5. **Stake amount** - Enter how much GEN to stake (minimum 42,000)
6. **Validator creation** - Submits the staking transaction
7. **Identity setup** - Set your validator's public profile (moniker, website, etc.)

<Callout type="info">
  **Save Your Validator Wallet Address!** After the wizard completes, note down your **Validator Wallet** address. You'll need this for your node configuration.
</Callout>

#### Operator Keystore Export

The wizard creates and exports an operator keystore file for you to transfer to your validator server. If your server is compromised, your staked funds (controlled by owner) remain safe.

### Verify Your Validator

After completing the wizard, verify your status:

```bash
genlayer staking validator-info --validator 0xYourValidatorWallet...
```

### Managing Your Validator

```bash
# Add more stake
genlayer staking validator-deposit --amount 1000gen

# Check active validators
genlayer staking active-validators

# Exit (initiates 7-epoch unbonding)
genlayer staking validator-exit --shares 100

# Claim after unbonding period
genlayer staking validator-claim

# Update identity
genlayer staking set-identity --validator 0x... --moniker "New Name"
```

---

## Set Up the Validator Node

Once your validator wallet is created and staked, set up your node software.

### Dependencies

#### LLM Access

Each validator needs access to a Large Language Model (LLM) for executing and evaluating Intelligent Contracts.

It is up to each validator to select the model they want to use.

Possible options:

- Run an open-source model locally on the same machine with a GPU
- Run an open-source model on a different machine
- Connect to a hosted inference provider (OpenAI, Anthropic, Heurist, Atoma network etc.)

#### ZKSync Full Node for the GenLayer Chain

Each validator needs access to a [ZKSync Full Node](https://docs.zksync.io/zksync-era/tooling/external-node) connected to the GenLayer chain. Validators use this node to read the chain state and submit transactions.

One full node can be shared between multiple validators. The optimal validator-to-node ratio is currently under evaluation.

### System Requirements

Below are the **initial** recommended system requirements. These guidelines may change as the network grows and evolves.

#### RAM

- **Recommended:** 16 GB
- **Why:**
  - GenLayer's _genvm_ can spawn multiple Sub-VMs for contract calls and non-deterministic blocks.
  - Each Sub-VM can consume up to ~4 GB of RAM for storage.

#### CPU

- **Recommended:** Modern multi-core processor with at least 8 cores/16 threads

#### Architecture

- **Recommended:** `AMD64`
- `ARM64` is not supported at this time

#### Storage

- **Recommended Disk Space:** 128 GB+
- **Preferred Type:** SSD or NVMe (M.2)

#### Network

- 100 Mbps connection
- **Recommended:**: 1 Gbps+

#### GPU (Optional)

- GPU is **Not Required**
- If you want to run LLMs locally, you will need to select appropriate hardware (typically a CUDA-compatible GPU with sufficient VRAM for the model you intend to use)

<Callout emoji="âš ï¸">
  These requirements are a starting point. As GenLayer evolves and usage
  patterns change (e.g., more complex AI-driven Intelligent Contracts), the
  recommended hardware may change.
</Callout>

#### Software

- Operating System - 64-bit Linux (Ubuntu, Debian, CentOS, etc.)
- `docker` - for running the WebDriver container
- `python3`, `python3-pip` and `python3-venv` for GenVM setup

### Setup

#### Download the node software

1. Select the version of the node you want to run by checking the available builds

   You can use this command to list available versions:

   ```sh
   curl -s "https://storage.googleapis.com/storage/v1/b/gh-af/o?prefix=genlayer-node/bin/amd64" | grep -o '"name": *"[^"]*"' | sed -n 's/.*\/\(v[^/]*\)\/.*/\1/p' | sort -ru
   ```

   You should see a list like this

   ```sh
      v0.4.4
      v0.4.3
      v0.4.2
      v0.4.1
      v0.4.0
      v0.3.11
      v0.3.10
      v0.3.9
      ...
      v0.3.2
      v0.3.1
      v0.3.0
      ...
   ```

   Typically, you will want to run the latest version

2. Download the packaged application
   ```sh
   export version=v0.4.4 # set your desired version here
   wget https://storage.googleapis.com/gh-af/genlayer-node/bin/amd64/${version}/genlayer-node-linux-amd64-${version}.tar.gz
   ```
3. Extract the node software
   ```sh
   mkdir -p ${version}
   tar -xzvf `genlayer-node-linux-amd64-${version}.tar.gz` -C `./${version}`
   ```
4. Change the directory

   ```sh
   cd `./${version}`
   ```

5. Run Genvm setup

   ```sh
   python3 ./third_party/genvm/bin/setup.py
   ```
It does following:

- Downloads missing runners if any
- Verifies runners hashes
- Sets `elf`/`mach-o` interpreter for all binaries (modules, genvm)
- Rust precompilation for built-in runners

### Configuration

Before you can start up the node, you need to configure it.

#### `config.yaml`

This is the main configuration file of your node. Without it, your node won't start

The file needs to be located at `configs/node/config.yaml`

You can use the following example configuration. **Note:** For most users, you will only need to modify the `zksyncurl` and `zksyncwebsocketurl` values below.

```yaml
# rollup configuration
rollup:
  genlayerchainrpcurl: "TODO: Set your GenLayer Chain ZKSync HTTP RPC URL here" # GenLayer Chain RPC URL
  genlayerchainwebsocketurl: "TODO: Set your GenLayer Chain ZKSync WebSocket RPC URL here" # GenLayer Chain WebSocket URL
# consensus contracts configuration
consensus:
  # Asimov - Phase 4
  contractmainaddress: "0x67fd4aC71530FB220E0B7F90668BAF977B88fF07" # ConsensusMain Smart Contract Address
  contractdataaddress: "0xB6E1316E57d47d82FDcEa5002028a554754EF243" # ConsensusData Smart Contract Address
  genesis: 4632386 # (Optional) Genesis block number for this consensus deployment. If not provided, it will be auto-detected by searching for the first log from the ConsensusMain contract.
# data directory
datadir: "./data/node"
# logging configuration
logging:
  level: "INFO"
  # json: `true` for json output to console, false for human readable log formatting
  json: false
  # Configuration for https://github.com/natefinch/lumberjack
  file:
    # enabled: set to `true` to save logs to a folder
    enabled: true
    level: "DEBUG"
    # folder: path to the folder where to store logs. Relative paths go under `datadir`.
    folder: logs
    # maxsize: maximum size in megabytes of the log file before it gets rotated.
    maxsize: 10
    # maxage: maximum number of days to retain old log files based on the timestamp encoded in their filename.
    maxage: 7
    # maxbackups: maximum number of old log files to retain. Set to 0 for no limit
    maxbackups: 100
    # localtime: determines if the time used for formatting the timestamps in backup files is the computer's local time. Set to `false` to use UTC time.
    localtime: false
    # compress: determines if the rotated log files should be compressed using gzip
    compress: true
# node configuration
node:
  # Uncomment if the ID of the node is different from the validator wallet address.
  # It is used to identify the node in the network.
  # id: "node"
  # Mode can be "validator" or "full".
  # Default value is "validator".
  mode: "validator"
  # Address of the ValidatorWallet contract (required for validator mode)
  validatorWalletAddress: ""
  # Address of the operator that owns the ValidatorWallet
  operatorAddress: ""
  admin:
    port: 9155
  rpc:
    port: 9151 # RPC server port
    endpoints:
      # Group-level configuration (enables/disables all methods in a group)
      groups:
        genlayer: true # gen_* methods (call, getContractSchema, etc.)
        genlayer_debug: true # gen_dbg_* methods (ping, load_test, trie)
        ethereum: true # eth_* proxy methods
        zksync: true # zks_* proxy methods
      # Method-level configuration (overrides group settings for specific methods)
      methods:
        gen_call: true
        gen_getContractSchema: true
        gen_getTransactionStatus: true
        gen_getTransactionReceipt: true
        gen_dbg_ping: true
        gen_dbg_load_test: true
        eth_blockNumber: true
        eth_getBlockByNumber: true
        eth_getBlockByHash: true
        eth_sendRawTransaction: true
        zks_getTransaction: true
  ops:
    port: 9153 # Metrics port
    endpoints:
      metrics: true # Enable metrics endpoint
      health: true # Enable health endpoint
      balance: true # Enable balance endpoint
# genvm configuration
genvm:
  root_dir: ./third_party/genvm
  start_manager: true # if true node will start genvm manager itself
  manager_url: http://127.0.0.1:3999
  permits: # Leave empty for autodiscovery, put a number for updating genvm permits on startup
# Advanced configuration
merkleforest:
  maxdepth: 16
  dbpath: "./data/node/merkle/forest/data.db"
  indexdbpath: "./data/node/merkle/index.db"
merkletree:
  maxdepth: 16
  dbpath: "./data/node/merkle/tree/"
# metrics configuration
metrics:
  interval: "15s" # Default interval for all collectors (can be overridden per collector)
  collectors:
    node:
      enabled: true
      # interval: "30s"  # Optional: Override default interval for this collector
    genvm:
      enabled: true
      # interval: "20s"  # Optional: Override default interval for this collector
      # enable_simulated_traffic: false  # Optional: Enable simulated network traffic metrics for GenVM processes (default: false)
      # simulated_rx_bytes_per_process: 1024  # Optional: Simulated received bytes per process per interval (default: 1024)
      # simulated_tx_bytes_per_process: 512   # Optional: Simulated transmitted bytes per process per interval (default: 512)
    webdriver:
      enabled: true
      # interval: "60s"  # Optional: Override default interval for this collector

```

#### Overriding Configuration with Environment Variables

Any configuration value in `config.yaml` can be overridden using environment variables with the prefix `GENLAYERNODE_`.

**Pattern:**

- Replace dots (`.`) with underscores (`_`)
- Convert to uppercase
- Add the `GENLAYERNODE_` prefix

**Examples:**

| Config Key | Environment Variable |
|------------|---------------------|
| `rollup.genlayerchainrpcurl` | `GENLAYERNODE_ROLLUP_GENLAYERCHAINRPCURL` |
| `rollup.genlayerchainwebsocketurl` | `GENLAYERNODE_ROLLUP_GENLAYERCHAINWEBSOCKETURL` |
| `consensus.contractmainaddress` | `GENLAYERNODE_CONSENSUS_CONTRACTMAINADDRESS` |
| `consensus.contractdataaddress` | `GENLAYERNODE_CONSENSUS_CONTRACTDATAADDRESS` |
| `consensus.genesis` | `GENLAYERNODE_CONSENSUS_GENESIS` |
| `node.mode` | `GENLAYERNODE_NODE_MODE` |
| `node.validatorWalletAddress` | `GENLAYERNODE_NODE_VALIDATORWALLETADDRESS` |
| `node.operatorAddress` | `GENLAYERNODE_NODE_OPERATORADDRESS` |
| `node.rpc.port` | `GENLAYERNODE_NODE_RPC_PORT` |
| `logging.level` | `GENLAYERNODE_LOGGING_LEVEL` |

**Usage example:**

```sh
# Override the RPC port
export GENLAYERNODE_CONSENSUS_CONTRACTMAINADDRESS="0x..."

# Set validator wallet address
export GENLAYERNODE_NODE_VALIDATORWALLETADDRESS="0x..."

# Set logging level
export GENLAYERNODE_LOGGING_LEVEL="DEBUG"
```

Environment variables take precedence over values in `config.yaml`, making them ideal for Docker deployments or sensitive values you don't want in configuration files.

#### GenVM Configuration

You need to set up an LLM for your node to use to provide answers to natural language prompts. You can use any LLM you wish, however the quality of its answers will affect the performance of your node.

<Callout>
  GenLayer has partnered with multiple LLM providers to offer free credits for validators:

  **[Heurist](https://www.heurist.ai/)** - A Layer 2 network for AI model hosting and inference, built on the ZK Stack. It offers serverless access to open-source AI models through a decentralized network. GenLayer Validators can obtain free [Heurist API credits](https://dev-api-form.heurist.ai) by using the referral code: _"genlayer"_.

  **[Comput3](https://genlayer.comput3.ai/)** - A decentralized compute network providing access to various AI models. GenLayer Validators can use the Comput3.ai inferencing API with access to llama3, hermes3 and qwen3 models. Validators can obtain free [Comput3 API credits](https://genlayer.comput3.ai/) to get started with their validator setup.

  **[io.net](/partners/ionet)** - A decentralized compute network providing GPU access for AI inference. GenLayer Validators can create an account at [id.io.net](https://id.io.net/login) and obtain free credits by [filling out this form](https://form.typeform.com/to/pDmCCViV).
</Callout>

The GenVM configuration files are located at `third_party/genvm/config/`

#### `genvm-module-llm.yaml`

This is the configuration file of the LLM module. In this file you can set up and configure various LLM providers, as well as the system prompts of your validator.

You should not need to modify this in general.

However, from here you can:
- turn on and off various LLMs by setting the `enabled` field to `false`: By default they all come enabled for you to use. You will get warnings in the logs for each one that's enabled and not configured. Disabling non used LLM providers will hide those warnings

Note environment variable names for LLM API keys (e.g., `HEURISTKEY`, `COMPUT3KEY`, `IOINTELLIGENCE_API_KEY`). You will need to ensure the appropriate key is correctly set before [running the node](#running-the-node).

#### `genvm-module-web.yaml`

This is the configuration of webdriver module that enables the GenVM to access the internet. You should not need to modify this.

#### `genvm-manager.yaml`

This is the configuration of the GenVM manager. You should not need to modify this. However, if you are running the node on
macos (natively), you may want to set `permits` to some large value, as auto-detection is not supported there yet, such as `32`.

#### Greyboxing LLMs

Greyboxing is a way to further customise your LLM setup to improve its performance as well as security.

<Callout type="info" emoji="ðŸ’¡">
  Greyboxing is an advanced feature. Familiarity with Lua scripting and LLM
  prompt engineering is recommended for customization.
</Callout>

`genvm-modules llm` provides user with ability to customize [greyboxing](/_temp/security-and-best-practices/grey-boxing) via lua scripting. Right now users can customize prompt templates, specify temperature and system prompt.

Related scripts are located at:

1. `./scripts/genvm-greyboxing.lua` â€“ user defined script
2. `./share/lib/genvm/greyboxing/lib-greyboxing.lua` â€“ more low-level library

<Callout emoji="ðŸ—ï¸">
  More features and built-in filters will be added soon
</Callout>

#### Import the Operator Key

The operator key is used by your node to sign blocks and perform validator duties.

#### Option 1: Import from CLI Wizard (Recommended)

If you used `genlayer staking wizard`, it exported an operator keystore file. Transfer this file to your validator server and import it:

```sh
./bin/genlayernode account import \
  --password "your node password" \
  --passphrase "password you set when exporting from wizard" \
  --path "/path/to/operator-keystore.json" \
  -c $(pwd)/configs/node/config.yaml \
  --setup
```

You should see:

```sh
Account imported:
  Address: 0xA0b12Fd2f3F7e86fEC458D114A5E7a6f571160a8
  Account setup as a validator
```

#### Option 2: Generate New Operator Key

You can also generate a new operator key directly on the server:

```sh
./bin/genlayernode account new -c $(pwd)/configs/node/config.yaml --setup --password "your secret password"
```

Then use this address when running the wizard on your local machine.

#### Restoring Your Operator Key

To restore from a backup (e.g., after migrating to a new server):

```sh
./bin/genlayernode account import \
  --password "your node password" \
  --passphrase "your backup encryption passphrase" \
  --path "/path/to/your/secure/backup.key" \
  -c $(pwd)/configs/node/config.yaml \
  --setup
```

<Callout type="warning" emoji="ðŸš¨">
  Always verify that your imported key works by checking the operator address matches what's configured for your validator.
</Callout>

#### Backing Up Your Operator Key

After setting up your operator key, back it up securely:

```sh
./bin/genlayernode account export \
  --password "your node password" \
  --address "your operator address" \
  --passphrase "your backup encryption passphrase" \
  --path "/path/to/your/secure/backup.key" \
  -c $(pwd)/configs/node/config.yaml
```

<Callout type="warning" emoji="ðŸš¨">
  **Important: Back up your operator key!** Losing access means you'll need to set up a new operator and update your validator configuration. Store the backup securely.
</Callout>

To print the private key from your backup file, use the `--print` flag. **Keep this private key secure and never share it.**


### Running the node

Once you have configured everything, you are ready to start the node.

<Callout type="warning" emoji="ðŸš¨">
    **Important:** Before starting the node, ensure you have:
    1. **Operator key** imported into the node (see "Import the Operator Key" above)
    2. **Validator wallet address** - obtained after joining as validator via `genlayer staking wizard` or `validator-join`

    Without both configured, your node will run as a full node instead of a validator.
</Callout>

#### Running the Node using the binary

1.  Set the LLM Provider API Key

    Set the appropriate environment variable for your chosen LLM provider:

    ```sh
    # For Heurist
    export HEURISTKEY='your_heurist_api_key'

    # For Comput3
    export COMPUT3KEY='your_comput3_api_key'

    # For io.net
    export IOINTELLIGENCE_API_KEY='your_ionet_api_key'

    # For other providers, use the appropriate environment variable name
    ```

2.  Run the WebDriver container

    ```sh
    docker compose up -d # Starts the WebDriver needed by the GenVM web module
    ```

3.  (Optional) Run two services (modules) in background (this is a crucial step for running _Intelligent_ contracts). This can be done automatically or manually.
    - To start them automatically in node configuration set `genvm.manage_modules` to `true`
    - To start them manually run
      ```bash
       ./third_party/genvm/bin/genvm-modules web & ./third_party/genvm/bin/genvm-modules llm &
      ```

<Callout type="info">
  Note: If you are using the default configuration, `genvm.manage_modules` is
  set to `true` by default, meaning the node will manage these modules
  automatically.
</Callout>

4. Checking Your Configuration

    To ensure your node is correctly configured, you can run the following command:

    ```sh
    ./bin/genlayernode doctor
    ```

    The `doctor` command now includes comprehensive GenVM diagnostics integration to validate:
    - Consensus contract configuration and accessibility
    - GenVM module connectivity and health status
    - LLM provider configuration and API connectivity
    - Network configuration and ZKSync node accessibility

5.  Run the node

    ```sh
    ./bin/genlayernode run -c $(pwd)/configs/node/config.yaml --password "your secret password" # The same password you used when creating the account
    ```

<Callout type="info">
  If you are running the node via SSH, the process might terminate if your
  connection drops. To prevent this, consider using a terminal multiplexer like
  `screen` or `tmux` to keep the node running in the background even if your SSH
  session ends. You can find a guide on using `screen`
  [here](https://www.networkworld.com/article/967925/how-the-linux-screen-tool-can-save-your-tasks-and-your-sanity-if-ssh-is-interrupted.html).
</Callout>

#### Running the Node using docker-compose

You can also run the GenLayer node using Docker and Docker Compose.

1. Create a `docker-compose.yaml` file with the following content:

```yaml
services:
  webdriver-container:
    container_name: genlayer-node-webdriver
    image: yeagerai/genlayer-genvm-webdriver:0.0.9
    shm_size: 2gb
    security_opt:
      - no-new-privileges:true
    environment:
      PORT: 4444
    ports:
      - "${WEBDRIVER_PORT:-4444}:4444"
    restart: unless-stopped
  genlayer-node:
    image: yeagerai/genlayer-node:${NODE_VERSION:-latest}
    entrypoint: ["sh", "-c", "/app/bin/genlayernode run --password ${NODE_PASSWORD:-12345678}"]
    container_name: genlayer-node
    restart: unless-stopped
    env_file:
      - path: ./.env
        required: false
    ports:
      - "${NODE_RPC_PORT:-9151}:9151"
      - "${NODE_OPS_PORT:-9153}:9153"
    volumes:
      - ${NODE_CONFIG_PATH:-./configs/node/config.yaml}:/app/configs/node/config.yaml:ro
      - ${NODE_DATA_PATH:-./data}:/app/data
      - ./genvm-module-web-docker.yaml:/app/third_party/genvm/config/genvm-module-web.yaml
      - /var/run/docker.sock:/var/run/docker.sock:ro # required for webdriver metrics collection
    security_opt:
      - no-new-privileges:true
    logging:
      driver: "json-file"
      options:
        max-size: "100m"
        max-file: "3"
        compress: "true"
    depends_on:
      - webdriver-container
    profiles:
      - node

```

2. Create `genvm-module-web-docker.yaml` for Docker networking:

The extracted tarball includes `third_party/genvm/config/genvm-module-web.yaml` configured for `localhost`, which works when running
the binary directly. For docker-compose, you need a version that points to the webdriver service name.

Create `genvm-module-web-docker.yaml` in the same directory as your `docker-compose.yaml`:

- Copy the contents of `third_party/genvm/config/genvm-module-web.yaml` into `genvm-module-web-docker.yaml`.
- Modify the `webdriver_host` configuration to use the service name `webdriver-container` instead of `localhost`:

```yaml
webdriver_host: http://webdriver-container:4444
```

This allows the node container to reach the webdriver container using Docker's internal networking.

The key difference:
- **Binary execution**: uses `localhost:4444` (webdriver runs on same machine)
- **Docker-compose**: uses `webdriver-container:4444` (container service name)


3. Set the required environment variables in a `.env` file:

<Callout type="info">
  This `.env` file serves two purposes: it configures Docker Compose variables (like `NODE_VERSION`, `NODE_PASSWORD`, ports) and can also include `GENLAYERNODE_*` variables to override node configuration values as described in [Overriding Configuration with Environment Variables](#overriding-configuration-with-environment-variables).
</Callout>

```env
# GenLayer Node Release Configuration

# =============================================================================
# WebDriver Configuration (required for GenVM)
# =============================================================================
WEBDRIVER_PORT=4444

# =============================================================================
# Node Service Configuration (optional - use node profile)
# =============================================================================
# Docker image version
NODE_VERSION=v0.4.0

# Keystore password (used to unlock the pre-imported wallet)
NODE_PASSWORD=12345678

# Path to node configuration file
NODE_CONFIG_PATH=./configs/node/config.yaml

# Path to node data directory (for persistence)
NODE_DATA_PATH=./data

# Port mappings
NODE_RPC_PORT=9151
NODE_OPS_PORT=9153

# LLM API Key (required for GenVM LLM module)
HEURISTKEY=
ANTHROPICKEY=
XAIKEY=
GEMINIKEY=
ATOMAKEY=
```

or simply use the provided `docker-compose.yaml`, `.env.example` and the `genvm-module-web-docker.yaml` from the extracted tarball.

4. Checking Your Configuration

To ensure your node is correctly configured, you can run the following command:

```sh
source .env && docker run --rm --env-file ./.env \
  -v ${NODE_CONFIG_PATH:-./configs/node/config.yaml}:/app/configs/node/config.yaml \
  yeagerai/genlayer-node:${NODE_VERSION:-v0.4.0} \
  ./bin/genlayernode doctor
```

5. Start the services using Docker Compose:

```sh
source .env && docker compose --profile node up -d
```

### Monitoring with Metrics

GenLayer validators expose comprehensive metrics that are ready for consumption by Prometheus and other monitoring tools. This allows you to monitor your validator's performance, health, and resource usage.

#### Accessing Metrics

The metrics endpoint is exposed on the operations port (default: 9153) configured in your `config.yaml`:

```yaml
node:
  ops:
    port: 9153 # Metrics port
    endpoints:
      metrics: true # Enable metrics endpoint
```

Once your node is running, you can access the metrics at:
```
http://localhost:9153/metrics
```

#### Available Metrics

The validator exposes various metric collectors that can be individually configured:

- **Node Metrics**: Core validator performance metrics including block processing, transaction handling, and consensus participation
- **GenVM Metrics**: Virtual machine performance metrics, including execution times and resource usage
- **WebDriver Metrics**: Metrics related to web access and external data fetching

#### Configuring Metrics Collection

You can customize metrics collection in your `config.yaml`:

```yaml
metrics:
  interval: "15s"  # Default collection interval
  collectors:
    node:
      enabled: true
      interval: "30s"  # Override interval for specific collector
    genvm:
      enabled: true
      interval: "20s"
    webdriver:
      enabled: true
      interval: "60s"
```

#### Example Metrics Query

To check if metrics are working correctly:

```bash
# Get all available metrics
curl http://localhost:9153/metrics

# Check specific metric (example)
curl -s http://localhost:9153/metrics | grep genlayer_node_
```

<Callout type="info">
  The metrics endpoint also provides `/health` and `/balance` endpoints on the same port for additional monitoring capabilities.
</Callout>

#### Monitoring Best Practices

1. **Set up alerts** for critical metrics like node synchronization status and missed blocks
2. **Monitor resource usage** to ensure your validator has sufficient CPU, memory, and disk space
3. **Track GenVM performance** to optimize LLM provider selection and configuration
4. **Use visualization tools** like Grafana to create dashboards for easy monitoring

<Callout emoji="ðŸ“Š">
  For production validators, we recommend setting up a complete monitoring stack with Prometheus and Grafana. This enables real-time visibility into your validator's performance and helps identify issues before they impact your validator's operation.
</Callout>

#### Logs and metrics forwarding

You can forward your logs and metrics to external systems for centralized monitoring and alerting by using the service `alloy` provided in the `docker-compose.yaml` from the extracted tarball.

#### Centralized Push to GenLayer Foundation Grafana Cloud (using Alloy)

To contribute your node's metrics and logs to the centralized GenLayer Foundation Grafana Cloud dashboard (improving aggregate network visibility, alerts, and community monitoring), use the built-in Alloy service.

**Why contribute?**
- Helps the Foundation and community track overall testnet health (validator participation, latency, resource usage).
- May positively influence testnet points/rewards (visible healthy nodes are prioritized).
- Setup takes 10â€“15 minutes once credentials are provided.

**Prerequisites**
- Metrics enabled in `config.yaml` (`endpoints.metrics: true` â€” default in recent versions).
- Ops port 9153 exposed in docker-compose (`ports: - "9153:9153"`).
- Credentials from the Foundation team (ask in #testnet-asimov):
  - `CENTRAL_MONITORING_URL` â€” Prometheus remote write base URL (e.g., `https://prometheus-prod-XX.grafana.net`)
  - `CENTRAL_LOKI_URL` â€” Loki push base URL (e.g., `https://logs-prod-XX.grafana.net`)
  - `MONITORING_USERNAME` â€” Instance ID (a number)
  - `MONITORING_PASSWORD` â€” Grafana Cloud API Key (with write permissions for metrics and logs)

**Steps**

1. **Create or update .env** (next to your docker-compose.yaml):

```env
# Grafana Cloud credentials (request from Foundation team in Discord)
CENTRAL_MONITORING_URL=https://prometheus-prod-...grafana.net
CENTRAL_LOKI_URL=https://logs-prod-...grafana.net
MONITORING_USERNAME=1234567890          # your instance ID
MONITORING_PASSWORD=glc_xxxxxxxxxxxxxxxxxxxxxxxxxxxx  # API key

# Your node labels (customize for easy filtering in dashboards)
NODE_ID=0xYourValidatorAddressOrCustomID
VALIDATOR_NAME=validatorname

# Usually defaults are fine
NODE_METRICS_ENDPOINT=localhost:9153
LOG_FILE_PATTERN=/var/log/genlayer/node*.log
METRICS_SCRAPE_INTERVAL=15s
```

2. **Add or verify the Alloy service in docker-compose.yaml (copy if missing):

```yaml
alloy:
  image: grafana/alloy:latest
  container_name: genlayer-node-alloy
  command:
    - run
    - /etc/alloy/config.river
    - --server.http.listen-addr=0.0.0.0:12345
    - --storage.path=/var/lib/alloy/data
  volumes:
    - ./alloy-config.river:/etc/alloy/config.river:ro
    - ${NODE_LOGS_PATH:-./data/node/logs}:/var/log/genlayer:ro
    - alloy_data:/var/lib/alloy
  environment:
    - CENTRAL_LOKI_URL=${CENTRAL_LOKI_URL}
    - CENTRAL_MONITORING_URL=${CENTRAL_MONITORING_URL}
    - MONITORING_USERNAME=${MONITORING_USERNAME}
    - MONITORING_PASSWORD=${MONITORING_PASSWORD}
    - NODE_ID=${NODE_ID}
    - VALIDATOR_NAME=${VALIDATOR_NAME}
    - NODE_METRICS_ENDPOINT=${NODE_METRICS_ENDPOINT}
    - SCRAPE_TARGETS_JSON=${SCRAPE_TARGETS_JSON:-}
    - METRICS_SCRAPE_INTERVAL=${METRICS_SCRAPE_INTERVAL:-15s}
    - METRICS_SCRAPE_TIMEOUT=${METRICS_SCRAPE_TIMEOUT:-10s}
    - ALLOY_SELF_MONITORING_INTERVAL=${ALLOY_SELF_MONITORING_INTERVAL:-60s}
    - LOG_FILE_PATTERN=${LOG_FILE_PATTERN:-/var/log/genlayer/node*.log}
    - LOKI_BATCH_SIZE=${LOKI_BATCH_SIZE:-1MiB}
    - LOKI_BATCH_WAIT=${LOKI_BATCH_WAIT:-1s}
  ports:
    - "12345:12345"  # Alloy UI for debugging
  restart: unless-stopped
  profiles:
    - monitoring

volumes:
  alloy_data:
```

3. **Create or update ./alloy-config.river** (use the provided version â€” it handles logs and metrics forwarding):

```river
// Grafana Alloy Configuration for GenLayer Node Telemetry
// Handles both log collection and metrics forwarding

// ==========================================
// Log Collection and Forwarding
// ==========================================

local.file_match "genlayer_logs" {
  path_targets = [{
    __path__ = coalesce(env("LOG_FILE_PATTERN"), "/var/log/genlayer/node*.log"),
  }]
}

discovery.relabel "add_labels" {
  targets = local.file_match.genlayer_logs.targets

  rule {
    target_label = "instance"
    replacement  = env("NODE_ID")
  }

  rule {
    target_label = "validator_name"
    replacement  = env("VALIDATOR_NAME")
  }

  rule {
    target_label = "component"
    replacement  = "alloy"
  }

  rule {
    target_label = "job"
    replacement  = "genlayer-node"
  }
}

loki.source.file "genlayer" {
  targets    = discovery.relabel.add_labels.output
  forward_to = [loki.write.central.receiver]
  tail_from_end = true
}

loki.write "central" {
  endpoint {
    url = env("CENTRAL_LOKI_URL") + "/loki/api/v1/push"
    basic_auth {
      username = env("MONITORING_USERNAME")
      password = env("MONITORING_PASSWORD")
    }
    batch_size = coalesce(env("LOKI_BATCH_SIZE"), "1MiB")
    batch_wait = coalesce(env("LOKI_BATCH_WAIT"), "1s")
  }
}

// ==========================================
// Prometheus Metrics Collection and Forwarding
// ==========================================

prometheus.scrape "genlayer_node" {
  targets = json_decode(coalesce(env("SCRAPE_TARGETS_JSON"), format("[{\"__address__\":\"%s\",\"instance\":\"%s\",\"validator_name\":\"%s\"}]", coalesce(env("NODE_METRICS_ENDPOINT"), "localhost:9153"), coalesce(env("NODE_ID"), "local"), coalesce(env("VALIDATOR_NAME"), "default"))))
  forward_to = [prometheus.relabel.metrics.receiver]
  scrape_interval = coalesce(env("METRICS_SCRAPE_INTERVAL"), "15s")
  scrape_timeout  = coalesce(env("METRICS_SCRAPE_TIMEOUT"), "10s")
}

prometheus.relabel "metrics" {
  forward_to = [prometheus.remote_write.central.receiver]
  // Optional: filter only GenLayer metrics to save bandwidth
  // rule {
  //   source_labels = ["__name__"]
  //   regex        = "genlayer_.*"
  //   action       = "keep"
  // }
}

prometheus.remote_write "central" {
  endpoint {
    url = env("CENTRAL_MONITORING_URL") + "/api/v1/write"
    basic_auth {
      username = env("MONITORING_USERNAME")
      password = env("MONITORING_PASSWORD")
    }
    queue_config {
      capacity          = 10000
      max_shards        = 5
      max_samples_per_send = 500
      batch_send_deadline = "15s"
    }
  }
}

// ==========================================
// Alloy Self-Monitoring
// ==========================================

prometheus.exporter.self "alloy" {}

prometheus.scrape "alloy" {
  targets    = prometheus.exporter.self.alloy.targets
  forward_to = []
  scrape_interval = coalesce(env("ALLOY_SELF_MONITORING_INTERVAL"), "60s")
}
```

4. **Start Alloy**:

```bash
docker compose --profile monitoring up -d
```

5. **Verify it works**:

- Open Alloy UI: http://localhost:12345/targets â€” the "genlayer_node" scrape target should show status **UP**.
- Check logs for successful sends:

```bash
docker logs genlayer-node-alloy | grep "sent batch"
```

```bash
docker logs genlayer-node-alloy | grep "remote_write"
```

Look for messages indicating successful batch sending (no error codes like 401, 403, 500).
- In Foundation Grafana Cloud: search for metrics with labels  
  `instance="${NODE_ID}"` or `validator_name="${VALIDATOR_NAME}"`  
  (example: `genlayer_node_uptime_seconds{instance="0xYourID"}`).

Troubleshooting
- No local metrics:

```bash
curl http://localhost:9153/metrics
```

â€” it should return Prometheus-formatted data.
Authentication errors (401/403): Double-check MONITORING_USERNAME and MONITORING_PASSWORD in .env.
No data pushed: Ensure URLs in .env have no trailing slash.
Help: Share Alloy logs

```bash
docker logs genlayer-node-alloy
```
