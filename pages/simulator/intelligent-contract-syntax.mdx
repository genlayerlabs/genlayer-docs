## Intelligent Contract Syntax

Intelligent Contracts extend traditional smart contract capabilities by processing natural language instructions and interfacing with web data. These contracts are written in Python and executed within the GenVM, a specialized virtual environment.

import { Callout } from 'nextra-theme-docs'

<Callout emoji="👾">
  The syntax presented here is a temporary placeholder used in the simulator. For the GenLayer blockchain the final syntax will include specialized keywords that streamline some of the processes currently handled through standard Python code.
</Callout>
## Import

When working with Intelligent Contracts, start by importing the necessary modules:

```python copy
import json
from genvm.contracts.base import icontract
from genvm.contracts.equivalence_principle import EquivalencePrinciple
```

- The `json` module is used for parsing and manipulating JSON data.
- The `icontract` module is imported from `genvm.contracts.base` and provides the necessary foundation to create an Intelligent Contract.
- The `EquivalencePrinciple` is imported from `genvm.contracts.equivalence_principle` and is used to ensure consensus among validators for non-deterministic outputs.

## Defining the Intelligent Contract Class
The `@icontract` decorator is used to define an Intelligent Contract class in Python, which allows the contract to be recognized within the GenVM environment. 

```python copy
@icontract
class YourContract:
    description: str = "Description of your contract goes here."
```
The `description` attribute stores text that explains what the contract is about.

## Initializing the Intelligent Contract

The constructor method, `__init__`, sets up the initial state of the contract and is called automatically when a new instance of the contract is created.

```python copy
def __init__(self, initial_state):
    self.state_variable = initial_state
```
This function takes a parameter, `initial_state`, and assigns it to `self.state_variable`. The `initial_state` parameter is passed to the contract at the time of its creation, defining the initial setup of the state variable. The `state_variable` holds critical information that dictates how the contract responds to interactions.

## Crafting Prompts for LLM and Web Browsing Interactions

When developing Intelligent Contracts, one critical functionality is interacting with Large Language Models (LLMs) and accessing web data. This is achieved by sending them specific prompts or queries based on the current needs of the contract or the incoming user requests.

Within your Intelligent Contract, you define a method (such as `your_method` in the example below) that constructs a prompt.

```python copy
async def your_method(self, request: str) -> None:
    prompt = f"""
Given the request: {request}
Determine if the request is a greeting.

Please respond in the following valid JSON format:
{{
 "explanation": str,
 "is_greeting": bool
}}
"""
```

The `async def` declaration allows `your_method` to prepare and send out prompts asynchronously without disrupting other operations of the contract. Actual calls to the LLM or Web Browsing and managing results, are done within the **Equivalence Principle** block.

## Equivalence Principle - Managing Intelligent Contract Operations

The Equivalence Principle is a cornerstone in ensuring that Intelligent Contracts function consistently across various validators, especially when handling non-deterministic outputs like responses from Large Language Models (LLMs) or data retrieved through web browsing. It plays a crucial role in how validators assess and agree on the outcomes proposed by the leader.

```python copy
async with EquivalencePrinciple(self, final_result, "The ['is_greeting'] value must be the same across all validators") as eq:
    result = await eq.call_llm(prompt)
    eq.set_result(result)
```

### How the Equivalence Principle Works

- The `async with` statement initiates an asynchronous context to ensure that actions within the Equivalence block are executed without blocking the contract’s other functionalities.

- Inside the block, `eq.call_llm(prompt)` is responsible for actually making calls to the LLM or web and retrieving the result.

- Once the data is processed, the final output is set in the `eq.set_result(result)`. Then the validators checking if the result from the leader meets the predefined criteria.

<Callout type="info" emoji="ℹ️">
  State variables cannot be set or accessed within the Equivalence Principle block as the block operates as a pure function, only the result is returned in the end. This is necessary to ensure consistency of the state when different validators execute the contract.
</Callout>

### Types of Equivalence Principles
Validators work to reach a consensus on whether the result set by the leader is acceptable which might involve direct comparison or qualitative evaluation, depending on the contract’s design. 

If the validators do not reach a consensus perhaps due to differing data interpretations or an error in data processing, the result might be challenged or an appeal process might be initiated.

#### Comparative Equivalence Principle

This method involves a direct comparison of results from different validators to ensure they fall within an acceptable margin of error, which is crucial when outputs can be quantitatively measured and compared. 

For example, if an intelligent contract is tasked with fetching the follower count of a Twitter account and results vary slightly among validators (e.g., one validator reports 42 followers and another reports 43), a small margin of error is permissible to consider the results equivalent (e.g., the a 5% margin of error is permissible).

#### Non-Comparative Equivalence Principle

In contrast, the non-comparative method assesses the adequacy of the leader's output based on predefined criteria, without necessitating other validators to replicate the exact output. This approach is less resource-intensive as it avoids redundant operations across validators. 

For instance, if the task is to summarize an article, validators would only need to evaluate the summary's accuracy and completeness instead of generating their own summaries, thus saving computational resources and reducing costs.

```python copy
async with EquivalencePrinciple(self, final_result, "The result must provide accurate information", comparative=False) as eq:
    result = await eq.perform_web browsing("https://example.com")
    eq.set_result(result)
```

By selecting the comparative mode (True or False), validators can either be required to produce directly comparable outputs or to assess the sufficiency of a provided result, tailoring the Equivalence Principle's application to the specific needs of the contract and the nature of the task. 

## Parsing result
After the result has been validated and finalized within the Equivalence Principle block, the  `json.loads()` function is used to parse the result into a JSON format making it easier to access and extract the data.

```python copy
result_json = json.loads(result)
```

## Result evaluation
Here the JSON-formatted result is evaluated to determine if the user's input was recognized. Depending on the outcome, the contract's state is updated. Then the method returns the complete JSON response, providing detailed information about the evaluation.

```python copy
if result_json['is_greeting'] is False:
    self.state_variable = result_json['is_greeting']
return result_json
```

## Complete example code

Here's a complete example code that demonstrates the structure and components of an Intelligent Contract:

```python copy
import json
from genvm.contracts.base import icontract
from genvm.contracts.equivalence_principle import EquivalencePrinciple

@icontract
class YourContract:
    def __init__(self, initial_state):
        self.state_variable = initial_state

    async def your_method(self, request: str) -> None:
        prompt = f"""
Given the request: {request}
Determine if the request is a greeting.

Please respond in the following valid JSON format:
{{
"explanation": str,
"is_greeting": bool
}}
"""
        async with EquivalencePrinciple(self, "The ['is_greeting'] value must be the same across all validators") as eq:
            result = await eq.call_llm(prompt)
            eq.set_result(result)

        result_json = json.loads(result)

        if result_json['is_greeting'] is False:
            self.state_variable = result_json['is_greeting']
        return result_json
```

