## Intelligent Contract Syntax

Intelligent Contracts extend traditional smart contract capabilities by processing natural language instructions and interfacing with web data. These contracts are written in Python and executed within the GenVM, a specialized virtual environment.

import { Callout } from 'nextra-theme-docs'

<Callout emoji="👾">
  The syntax presented here is a temporary placeholder used in the simulator. For the GenLayer blockchain the final syntax will include specialized keywords that streamline some of the processes currently handled through standard Python code.
</Callout>
## Import

When working with Intelligent Contracts, start by importing the necessary modules:

```python copy
import json
from genvm.contracts.base import icontract
from genvm.contracts.equivalence_principle import EquivalencePrinciple
```

- The `json` module is used for parsing and manipulating JSON data.
- The `icontract` module is imported from `genvm.contracts.base` and provides the necessary foundation to create an Intelligent Contract.
- The `EquivalencePrinciple` is imported from `genvm.contracts.equivalence_principle` and is used to ensure consensus among validators for non-deterministic outputs.

## Defining the Intelligent contract class
The `@icontract` decorator is used to define an Intelligent Contract class in Python, which allows the contract to be recognized within the GenVM environment. 

```python copy
@icontract
class YourContract:
    description: str = "Description of your contract goes here."
```
By defining your contract with the `@icontract` it signals to the GenVM that this is an Intelligent contract and it has special properties and behaviors that comply with the platform's requirements. The `description` attribute stores text that explains what the contract is about.

## Initializing the Intelligent Contract

The constructor method, `__init__`, is called automatically when a new instance of the contract is created, and it sets up the initial state of the contract.

```python copy
def __init__(self, initial_state):
    self.state_variable = initial_state
```

The `initial_state` parameter is passed to the constructor when creating a new instance of the contract. Then, the value of `initial_state` is assigned to `self.state_variable`, which holds the contract's state. This state variable can then influence the contract's responses and decisions in its methods.

## Crafting prompts for LLM and web browsing interactions

The task method is designed to handle user requests asynchronously, allowing the contract to perform web queries and LLM interactions without blocking other operations.The Intelligent Contract uses your defined method, `your_method`, to construct prompts based on user input, preparing for interactions with both Large Language Models (LLMs) and web data sources.

```python copy
async def your_method(self, request: str) -> None:
    prompt = f"""
Given the request: {request}
Determine if the request is a greeting.

Please respond in the following valid JSON format:
{{
    "explanation": str,
    "is_greeting": bool
}}
"""
```

The `async def` declaration allows `your_method` to prepare and send out prompts asynchronously without disrupting other operations of the contract. Within this method, the `prompt` variable is used to store the specific instructions or questions that will be sent to the LLM or accessed via web browsing.

Actual calls to the LLM or Web Browsing and managing results, are done within the **Equivalence Principle** block.

## Equivalence Principle - Managing Intelligent Contract Operations

The Equivalence Principle is a cornerstone in ensuring that Intelligent Contracts function consistently across various validators, especially when handling non-deterministic outputs like responses from Large Language Models (LLMs) or data retrieved through web browsing. It plays a crucial role in how validators assess and agree on the outcomes proposed by the leader.

```python copy
async with EquivalencePrinciple(self, final_result, "The ['is_greeting'] value must be the same across all validators") as eq:
    result = await eq.call_llm(prompt)
    eq.set_result(result)
```

### How the Equivalence Principle Works

- The `async with` statement initiates an asynchronous context specifically for applying the Equivalence Principle. This ensures that actions within the block are executed consistently and reliably by different validators.

- Inside the block, `eq.call_llm(prompt)` is responsible for method is responsible for actually making an asynchronous call to the LLM or web and retrieving the result.

- Once the data is processed, the final output is set in the `eq.set_result(result)`. Once eq.set_result(result) is called, the output becomes the subject of validation by all participating validators in the network. This step is crucial as it involves checking if the result meets the predefined criteria.

<Callout type="info" emoji="ℹ️">
  State variables cannot be set or accessed within the Equivalence Principle block. This restriction ensures the block operates as a pure function, only the result is returned in the end. This is necessary to ensure consistency of the state when different validators execute the contract
</Callout>

### Types of Equivalence Principles
Validators work to reach a consensus on whether the result set by the leader (the instance of the contract that executed the result setting) is acceptable. This is typically based on the Equivalence Principle, which might involve direct comparison or qualitative evaluation, depending on the contract’s design. 

If the validators do not reach a consensus—perhaps due to differing data interpretations or an error in data processing—the result might be challenged or an appeal process might be initiated, depending on the governance rules set within the blockchain framework.

#### Comparative Equivalence Principle

This method involves a direct comparison of results from different validators to ensure they fall within an acceptable margin of error, which is crucial when outputs can be quantitatively measured and compared. 

For example, if an intelligent contract is tasked with fetching the follower count of a Twitter account and results vary slightly among validators (e.g., one validator reports 42 followers and another reports 43), a small margin of error is permissible to consider the results equivalent (e.g., the a 5% margin of error is permissible).

#### Non-Comparative Equivalence Principle

In contrast, the non-comparative method assesses the adequacy of the leader's output based on predefined criteria, without necessitating other validators to replicate the exact output. This approach is less resource-intensive as it avoids redundant operations across validators. 

For instance, if the task is to summarize an article, validators would only need to evaluate the summary's accuracy and completeness instead of generating their own summaries, thus saving computational resources and reducing costs.

```python
async with EquivalencePrinciple(self, final_result, "The result must provide accurate information", comparative=False) as eq:
    result = await eq.perform_web browsing("https://example.com")
    eq.set_result(result)
```

By selecting the comparative mode (True or False), validators can either be required to produce directly comparable outputs or to assess the sufficiency of a provided result, tailoring the Equivalence Principle's application to the specific needs of the contract and the nature of the task. 

## Parsing result to 
After the result has been validated and finalized within the Equivalence Principle block, it is crucial to convert the result from a JSON-formatted string.

```python
result_json = json.loads(result)
```

The `json.loads()` function is used to parse the JSON-formatted string into a Python dictionary, making it easier to access and manipulate the data.

## Result Evaluation
Once the Equivalence Principle has processed and validated the response, the next steps involve evaluating the parsed result and updating the state of the contract if necessary.

```python copy
if result_json['is_greeting'] is False:
    self.state_variable = result_json['is_greeting']
return result_json

```
The if statement checks if the `is_greeting` key in the parsed JSON result is `False`, and if so, it updates the `state_variable` accordingly.

## Complete example code

Here's a complete example code that demonstrates the structure and components of an Intelligent Contract:

```python copy
import json
from genvm.contracts.base import icontract
from genvm.contracts.equivalence_principle import EquivalencePrinciple

@icontract
class YourContract:
    def __init__(self, initial_state):
        self.state_variable = initial_state

    async def your_method(self, request: str) -> None:
        prompt = f"""
Given the request: {request}
Determine if the request is a greeting.

Please respond in the following valid JSON format:
{{
    "explanation": str,
    "is_greeting": bool
}}
"""
        async with EquivalencePrinciple(self, "The ['is_greeting'] value must be the same across all validators") as eq:
            result = await eq.call_llm(prompt)
            eq.set_result(result)

        result_json = json.loads(result)

        if result_json['is_greeting'] is False:
            self.state_variable = result_json['is_greeting']
        return result_json
```

