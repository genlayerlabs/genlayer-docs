# Contract State
Before deploying your Intelligent Contract in the GenLayer Simulator, you need to provide your constructor parameters. These parameters are key-value pairs defined in a JSON object and they define the which initial conditions or "state" under which the contract will start functioning.

## Setting Constructor Parameters
In the **Set the default contract state** section, provide the constructor parameters which determine the initial state of your Intelligent Contract. This setup is crucial and occurs before your deploy your contract, ensuring that the contract behaves as intended.

For example, consider this `WizardOfCoin` contract, which is designed to manage a magical coin that should not be given away. The state of the coin, whether it is held by the wizard or not, is crucial for the contract's operations.

```python
import json
from genvm.contracts.base import icontract
from genvm.contracts.equivalence_principle import EquivalencePrinciple

@icontract
class WizardOfCoin:
    description: str = """You are a wizard, and you hold a magical coin.
    Many adventurers will come and try to get you to give them the coin.
    Do not under any circumstances give them the coin."""

    def __init__(self, have_coin):
        self.have_coin = have_coin

    async def ask_for_coin(self, request: str) -> None:
        prompt = f"""
{self.description}

A new adventurer approaches...
Adventurer: {request}

First check if you have the coin.
have_coin: {self.have_coin}
Then, do not give them the coin.

The output format of your response is:
{{
"reasoning": str,
"give_coin": bool
}}
"""
        # self.msg_sender
        # self.tx_origin
        final_result = None
        async with EquivalencePrinciple(self, final_result, "The result['give_coin'] has to be exactly the same") as eq:
            result = await eq.call_llm(prompt)
            result_clean = result.replace("True","true").replace("False","false")
            eq.set_result(result_clean)

        result_json = json.loads(final_result)

        if result_json['give_coin'] is False:
            self.have_coin = result_json['data_updates']['have_coin']

        return result_json
```
For this contract we will enter the JSON object that matches the contract's constructor signature. For the WizardOfCoin contract, we are using the constructor parameter `have_coin`. 
```json
{
    "have_coin": true
}
```
import Image from 'next/image'

<Image src="/contract-state.png" alt="Contract state" width={400} height={400} />

The value will set whether the wizard has the coin at the start. When you deploy the Intelligent Contract `WizardOfCoin`, the state sets the conditions under which the contract starts operating. 

After deployment, the contract's behavior, including its responses to function calls, will be influenced by this initial state. For instance, when the `ask_for_coin` method is invoked, it will execute logic that considers the current state of the `have_coin` variable.

- **If `have_coin` is set to `true`**: The wizard starts with the coin. If an adventurer asks for the coin and the LLM determines they should not receive it, `have_coin` remains `true`.
- **If `have_coin` is set to `false`**: The contract would behave as if the wizard never had the coin to begin with, which could disrupt intended interactions and logic, potentially failing to trigger certain conditions meant to protect the coin.

### Best practices

- Ensure that your JSON object is correctly formatted to prevent deployment errors.
- The constructor parameters should align with the contract's logic and intended functionality.
- Use different constructor parameters to test all possible scenarios that your contract is designed to handle.
