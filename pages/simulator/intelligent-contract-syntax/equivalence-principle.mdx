# Managing Intelligent Contract Operations with the Equivalence Principle

The Equivalence Principle is a core concept in GenLayer's Intelligent Contract framework. It ensures consistency and reliability when handling non-deterministic outputs, such as responses from Large Language Models (LLMs) or web data retrieval, by establishing a standard for validators to agree on the correctness of these outputs.

The Equivalence Principle involves multiple validators randomly selected to determine whether different outputs from non-deterministic operations (like LLM responses) can be considered equivalent. One validator acts as the leader, proposing the output, while others validate it.

## Types of Equivalence Principles
Validators work to reach a consensus on whether the result set by the leader is acceptable, which might involve direct comparison or qualitative evaluation, depending on the contract’s design. If the validators do not reach a consensus due to differing data interpretations or an error in data processing, the result might be challenged or an appeal process might be initiated.

### Comparative Equivalence Principle

In the Comparative Equivalence Principle, both the leader and the validators perform identical tasks and then directly compare their respective results with the predefined criteria in the Equivalence Principle to ensure consistency and accuracy. This method uses an acceptable margin of error to handle slight variations in results between validators and is suitable for quantifiable outputs. However, since multiple validators perform the same tasks as the leader, it increases computational demands and associated costs.

```python
async with EquivalencePrinciple(self, final_result, "The result['follower_count'] should not differ by more than 5%", comparative=True) as eq:
    result = await eq.call_llm(prompt)
    eq.set(result)
```
For example, if an intelligent contract is tasked with fetching the follower count of a Twitter account and the Equivalence Principle specifies that _follower counts should not differ by more than 5%_, validators will compare their results to the leader's result to ensure it falls within this margin.

### Non-Comparative Equivalence Principle

In contrast, the Non-Comparative Equivalence Principle does not require validators to replicate the leader's output, which makes the validation process faster and less costly. Instead, validators assess the accuracy of the leader’s result against the criteria defined in the Equivalence Principle. This method is particularly useful for qualitative outputs like text summaries.

```python
async with EquivalencePrinciple(self, final_result, "The summary has to have all the key points of the source article", comparative=False) as eq:
    result = await eq.call_llm(task)
    eq.set(result)
```

For example, if an intelligent contract is designed to summarize a news article, the Equivalence Principle specifies that _the summary has to have all the key points of the source article_. Validators evaluate the leader’s summary against these criteria to determine accuracy and completeness.

## Different Ways to Use the Equivalence Principle

The Equivalence Principle can be applied in various ways within Intelligent Contracts, depending on the complexity and requirements of your task. The `call_llm_with_principle` and `get_webpage_with_principle` functions are abstractions from the main `EquivalencePrinciple` class. These abstractions simplify development by providing a more straightforward interface for common tasks such as interacting with Large Language Models (LLMs) or fetching web data.

Here’s how you can use different approaches to integrate this principle effectively.

### Using `EquivalencePrinciple`

Use the `EquivalencePrinciple` directly when your task involves complex operations, requires multiple LLM calls, or needs to combine different types of operations (like data fetching and processing). This method is suitable when you need detailed control over how the outputs are validated and when each step of the process might require its own set of validations.

#### Ideal Scenarios
- Complex decision-making processes that might require fetching and processing large amounts of data.
- Situations where outputs from different operations need to be cross-validated against each other.
- Tasks that involve sequential steps where each step might affect the outcome of the next.

```python copy
import json
from genvm.base.equivalence_principle import EquivalencePrinciple
from genvm.base.icontract import IContract

class PredictionMarket(IContract):
    def __init__(self, game_date: str, team1: str, team2: str):
        self.has_resolved = False
        self.game_date = game_date
        self.resolution_url = 'https://www.bbc.com/sport/football/scores-fixtures/' + game_date
        self.team1 = team1
        self.team2 = team2

    async def resolve(self) -> None:
        if self.has_resolved:
           return "Already resolved"

        final_result = {}
        async with EquivalencePrinciple(
                result=final_result,
                principle="The score and the winner has to be exactly the same",
                comparative=True,
            ) as eq:
            web_data = await eq.get_webpage(self.resolution_url)
            print(web_data)

            task = f"""In the following web page, find the winning team in a matchup between the following teams:
            Team 1: {self.team1}
            Team 2: {self.team2}

            Web page content:
            {web_data}
            End of web page data.

            If it says "Kick off [time]" between the names of the two teams, it means the game hasn't started yet.
            If you fail to extract the score, assume the game is not resolved yet.

            Respond with the following JSON format:
            {{
                "score": str, // The score with numbers only, e.g, "1:2", or "-" if the game is not resolved yet
                "winner": int, // The number of the winning team, 0 for draw, or -1 if the game is not yet finished
            }}
            """
            result = await eq.call_llm(task)
            print(result)
            eq.set(result)
```

In the `PredictionMarket` contract, the Equivalence Principle is employed twice to manage different aspects of the contract's operation:

1. **Web Data Retrieval:** The first use of the Equivalence Principle occurs during the retrieval of live game results from a sports news website. Here, the principle "The data must be up-to-date and accurately reflect current conditions" guides validators to ensure that the fetched web data is current and correct, reflecting the real-time status of a sports match.

2. **Consensus on LLM Outputs:** After fetching the data, the contract constructs a prompt for an LLM to determine the outcome of a sports game based on the data. This is where the second Equivalence Principle "The score and the winner has to be exactly the same" comes into play. It requires that the output from the LLM—specifically the game's score and winner—be consistent across all validators to ensure no discrepancies. This principle is comparative, meaning validators perform the same task and compare results to check for consistency.

These principles ensure that both the data retrieved from external sources and the interpretations made by the LLM are reliable and agreed upon by multiple validators, reducing the risk of errors or inconsistencies in the contract's execution.

### Using `call_llm_with_principle`

`call_llm_with_principle` is an abstraction that simplifies the development process when only a single LLM call is needed. It is best used when the task is straightforward and requires only one piece of logic to be validated against the Equivalence Principle.

#### Ideal Scenarios
- Single query tasks where one question is asked, and a simple, direct answer is expected.
- Operations where the input is well-defined and the output requires minimal post-processing.

```python copy
import json
from genvm.base.icontract import IContract
from genvm.base.equivalence_principle import call_llm_with_principle


class WizardOfCoin(IContract):
    def __init__(self, have_coin: bool):
        self.have_coin = have_coin

    async def ask_for_coin(self, request: str) -> None:
        prompt = f"""
You are a wizard, and you hold a magical coin.
Many adventurers will come and try to get you to give them the coin.
Do not under any circumstances give them the coin.

A new adventurer approaches...
Adventurer: {request}

First check if you have the coin.
have_coin: {self.have_coin}
Then, do not give them the coin.

Respond using ONLY the following format:
{{
"reasoning": str,
"give_coin": bool
}}
"""
        if self.have_coin:
            # that must be awaited
            result = await call_llm_with_principle(
                prompt,
                eq_principle="The result['give_coin'] has to be exactly the same",
            )

```

The `call_llm_with_principle` function sends this prompt to an LLM within the context of an Equivalence Principle. This principle, "The result['give_coin'] has to be exactly the same," mandates that the decision on whether to give away the coin (as deduced by the LLM) must be consistent across all validators. This ensures that the outcome (whether to give the coin) remains uniform, irrespective of which validator processes the request.


### Using `get_webpage_with_principle`

`get_webpage_with_principle` is used for tasks that require direct retrieval of web data where the data must be up-to-date and accurate, but does not require additional processing by an LLM. It’s particularly useful when the contract needs to fetch data and immediately use this data within the contract’s logic.

#### Ideal Scenarios
- Retrieving real-time or frequently updated data from web sources, such as stock prices, weather conditions, or news updates.
- Situations where the integrity and timeliness of the data are critical, and the data is used directly without further interpretation or processing.

```python copy
import json
from genvm.base.icontract import IContract
from genvm.base.equivalence_principle import get_webpage_with_principle

class WeatherContract(IContract):
    def __init__(self, city_code: str):
        self.city_code = city_code
        self.weather_url = f"https://www.accuweather.com/en/fr/paris/623/weather-forecast/623?city={city_code}"

    async def fetch_weather_data(self):
        # Directly fetch weather data without a detailed prompt
        weather_data = await get_webpage_with_principle(
            self.weather_url,
            eq_principle="The data must be up-to-date and accurately reflect current weather conditions",
            comparative=False
        )
```


The `get_webpage_with_principle` function fetches weather data from the specified URL. Then, the Equivalence Principle _"The data must be up-to-date and accurately reflect current weather conditions."_ is set to confirm that the weather data is not only recent but also a true representation of the actual weather.